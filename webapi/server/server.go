package server

import (
	"context"
	"errors"
	"fmt"
	"log"
	"os"
	"os/exec"
	"strings"

	"bitbucket.org/dexterchaney/whoville/utils"
	"bitbucket.org/dexterchaney/whoville/vault-helper/kv"
	pb "bitbucket.org/dexterchaney/whoville/webapi/rpc/apinator"
	gql "github.com/graphql-go/graphql"
)

//Server implements the twirp api server endpoints
type Server struct {
	VaultToken string
	VaultAddr  string
	GQLSchema  gql.Schema
	Log        *log.Logger
}

//NewServer Creates a new server struct and initializes the GraphQL schema
func NewServer(VaultAddr string, VaultToken string) *Server {
	s := Server{}
	s.VaultToken = VaultToken
	s.VaultAddr = VaultAddr
	s.Log = log.New(os.Stdout, "[INFO]", log.LstdFlags)

	return &s
}

//ListProjectTemplates lists the templates under the requested project
func (s *Server) ListServiceTemplates(ctx context.Context, req *pb.ListReq) (*pb.ListResp, error) {
	mod, err := kv.NewModifier(s.VaultToken, s.VaultAddr)
	if err != nil {
		utils.LogErrorObject(err, s.Log, false)
		return nil, err
	}

	listPath := "templates/" + req.Project + "/" + req.Service
	secret, err := mod.List(listPath)
	if err != nil {
		utils.LogErrorObject(err, s.Log, false)
		return nil, err
	}
	if secret == nil {
		err := fmt.Errorf("Could not find any templates under %s", req.Project+"/"+req.Service)
		utils.LogErrorObject(err, s.Log, false)
		return nil, err
	}
	utils.LogWarningsObject(secret.Warnings, s.Log, false)
	if len(secret.Warnings) > 0 {
		err := errors.New("Warnings generated from vault " + req.Project + "/" + req.Service)
		utils.LogErrorObject(err, s.Log, false)
		return nil, err
	}

	fileNames := []string{}
	for _, fileName := range secret.Data["keys"].([]interface{}) {
		if strFile, ok := fileName.(string); ok {
			if strFile[len(strFile)-1] != '/' { // Skip subdirectories where template files are stored
				fileNames = append(fileNames, strFile)
			}
		}
	}

	return &pb.ListResp{
		Templates: fileNames,
	}, nil
}

// GetTemplate makes a request to the vault for the template found in <project>/<service>/<file>/template-file
// Returns the template data in base64 and the template's extension. Returns any errors generated by vault
func (s *Server) GetTemplate(ctx context.Context, req *pb.TemplateReq) (*pb.TemplateResp, error) {
	// Connect to the vault
	mod, err := kv.NewModifier(s.VaultToken, s.VaultAddr)
	if err != nil {
		utils.LogErrorObject(err, s.Log, false)
		return nil, err
	}

	// Get template data from information in request.
	path := "templates/" + req.Project + "/" + req.Service + "/" + req.File + "/template-file"
	data, err := mod.ReadData(path)
	if err != nil {
		utils.LogErrorObject(err, s.Log, false)
		return nil, err
	}
	if data == nil {
		err := errors.New("No file " + req.File + " under " + req.Project + "/" + req.Service)
		utils.LogErrorObject(err, s.Log, false)
		return nil, err
	}

	// Return retrieved data in response
	return &pb.TemplateResp{
		Data: data["data"].(string),
		Ext:  data["ext"].(string)}, nil
}

// Validate checks the vault to see if the requested credentials are validated
func (s *Server) Validate(ctx context.Context, req *pb.ValidationReq) (*pb.ValidationResp, error) {
	mod, err := kv.NewModifier(s.VaultToken, s.VaultAddr)
	if err != nil {
		utils.LogErrorObject(err, s.Log, false)
		return nil, err
	}
	mod.Env = req.Env

	servicePath := "verification/" + req.Project + "/" + req.Service
	data, err := mod.ReadData(servicePath)
	if err != nil {
		utils.LogErrorObject(err, s.Log, false)
		return nil, err
	}

	if data == nil {
		err := errors.New("No verification for " + req.Project + "/" + req.Service + " found under " + req.Env + " environment")
		utils.LogErrorObject(err, s.Log, false)
		return nil, err
	}
	return &pb.ValidationResp{IsValid: data["verified"].(bool)}, nil
}

//GetValues gets values requested from the vault
func (s *Server) GetValues(ctx context.Context, req *pb.GetValuesReq) (*pb.ValuesRes, error) {

	environments := []*pb.ValuesRes_Env{}
	envStrings := []string{"dev", "QA", "local"}
	for _, environment := range envStrings {
		mod, err := kv.NewModifier(s.VaultToken, s.VaultAddr)
		if err != nil {
			utils.LogErrorObject(err, s.Log, false)
			return nil, err
		}
		mod.Env = environment
		projects := []*pb.ValuesRes_Env_Project{}
		//get a list of projects under values
		projectPaths, err := s.getPaths(mod, "values/")
		if err != nil {
			utils.LogErrorObject(err, s.Log, false)
			return nil, err
		}

		for _, projectPath := range projectPaths {
			services := []*pb.ValuesRes_Env_Project_Service{}
			//get a list of files under project
			servicePaths, err := s.getPaths(mod, projectPath)
			//fmt.Println("filePaths")
			//fmt.Println(filePaths)
			if err != nil {
				utils.LogErrorObject(err, s.Log, false)
				return nil, err
			}

			for _, servicePath := range servicePaths {
				files := []*pb.ValuesRes_Env_Project_Service_File{}
				//get a list of files under project
				filePaths, err := s.getPaths(mod, projectPath)
				//fmt.Println("filePaths")
				//fmt.Println(filePaths)
				if err != nil {
					utils.LogErrorObject(err, s.Log, false)
					return nil, err
				}

				for _, filePath := range filePaths {
					vals := []*pb.ValuesRes_Env_Project_Service_File_Value{}
					//get a list of values
					valueMap, err := mod.ReadData(filePath)
					if err != nil {
						err := fmt.Errorf("Unable to fetch data from %s", filePath)
						utils.LogErrorObject(err, s.Log, false)
						return nil, err
					}
					if valueMap != nil {
						//fmt.Println("data at path " + path)
						for key, value := range valueMap {
							kv := &pb.ValuesRes_Env_Project_Service_File_Value{Key: key, Value: value.(string), Source: "value"}
							vals = append(vals, kv)
							//data = append(data, value.(string))
						}

					}
					file := &pb.ValuesRes_Env_Project_Service_File{Name: getPathEnd(filePath), Values: vals}
					files = append(files, file)
				}
				service := &pb.ValuesRes_Env_Project_Service{Name: getPathEnd(servicePath), Files: files}
				services = append(services, service)
			}
			project := &pb.ValuesRes_Env_Project{Name: getPathEnd(projectPath), Services: services}
			projects = append(projects, project)
		}
		env := &pb.ValuesRes_Env{Name: environment, Projects: projects}
		environments = append(environments, env)
	}
	return &pb.ValuesRes{
		Envs: environments,
	}, nil
}
func (s *Server) getPaths(mod *kv.Modifier, pathName string) ([]string, error) {
	secrets, err := mod.List(pathName)
	//fmt.Println("secrets " + pathName)
	//fmt.Println(secrets)
	pathList := []string{}
	if err != nil {
		utils.LogErrorObject(err, s.Log, false)
		return nil, fmt.Errorf("Unable to list paths under %s in %s", pathName, mod.Env)
	} else if secrets != nil {
		//add paths
		slicey := secrets.Data["keys"].([]interface{})
		//fmt.Println("secrets are")
		//fmt.Println(slicey)
		for _, pathEnd := range slicey {
			//List is returning both pathEnd and pathEnd/
			path := pathName + pathEnd.(string)
			pathList = append(pathList, path)
		}
		//fmt.Println("pathList")
		//fmt.Println(pathList)
		return pathList, nil
	}
	return pathList, nil
}
func (s *Server) getTemplateFilePaths(mod *kv.Modifier, pathName string) ([]string, error) {
	secrets, err := mod.List(pathName)

	pathList := []string{}
	if err != nil {
		utils.LogErrorObject(err, s.Log, false)
		return nil, fmt.Errorf("Unable to list paths under %s in %s", pathName, mod.Env)
	} else if secrets != nil {
		//add paths
		slicey := secrets.Data["keys"].([]interface{})

		for _, pathEnd := range slicey {
			//List is returning both pathEnd and pathEnd/
			path := pathName + pathEnd.(string)
			pathList = append(pathList, path)
		}

		subPathList := []string{}
		for _, path := range pathList {
			subsubList, _ := s.templateFileRecurse(mod, path)
			for _, subsub := range subsubList {
				//List is returning both pathEnd and pathEnd/
				subPathList = append(subPathList, subsub)
			}
		}
		return subPathList, nil
	}
	return pathList, nil
}
func (s *Server) templateFileRecurse(mod *kv.Modifier, pathName string) ([]string, error) {
	subPathList := []string{}
	subsecrets, err := mod.List(pathName)
	if err != nil {
		utils.LogErrorObject(err, s.Log, false)
		return subPathList, err
	} else if subsecrets != nil {
		subslice := subsecrets.Data["keys"].([]interface{})
		if subslice[0] != "template-file" {
			for _, pathEnd := range subslice {
				//List is returning both pathEnd and pathEnd/
				subpath := pathName + pathEnd.(string)
				subsublist, _ := s.templateFileRecurse(mod, subpath)
				if len(subsublist) != 0 {
					for _, subsub := range subsublist {
						//List is returning both pathEnd and pathEnd/
						subPathList = append(subPathList, subsub)
					}
				}
				subPathList = append(subPathList, subpath)
			}
		} else {
			subPathList = append(subPathList, pathName)
		}
	}
	return subPathList, nil
}

func getPathEnd(path string) string {
	strs := strings.Split(path, "/")
	for strs[len(strs)-1] == "" {
		strs = strs[:len(strs)-1]
	}
	return strs[len(strs)-1]
}

// UpdateAPI takes the passed URL and downloads the given build of the UI
func (s *Server) UpdateAPI(ctx context.Context, req *pb.UpdateAPIReq) (*pb.NoParams, error) {
	scriptPath := "./getArtifacts.sh"
	//buildNum := strconv.FormatInt(int64(req.Build), 10)
	buildNum := req.Build
	//fmt.Println(buildNum)
	for len(buildNum) < 5 {
		buildNum = "0" + buildNum
	}
	cmd := exec.Command(scriptPath, buildNum)
	cmd.Dir = "/etc/opt/vaultAPI"
	err := cmd.Run()
	return &pb.NoParams{}, err
}

func (s *Server) ResetServer(ctx context.Context, req *pb.ResetReq) (*pb.NoParams, error) {
	s.VaultToken = req.PrivToken
	return &pb.NoParams{}, nil
}
func (s *Server) CheckConnection(ctx context.Context, req *pb.NoParams) (*pb.CheckConnResp, error) {
	if len(s.VaultToken) == 0 {
		return &pb.CheckConnResp{
			Connected: false,
		}, nil
	}
	return &pb.CheckConnResp{
		Connected: true,
	}, nil

}
