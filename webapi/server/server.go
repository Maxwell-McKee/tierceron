package server

import (
	"context"
	"errors"
	"fmt"

	"bitbucket.org/dexterchaney/whoville/vault-helper/kv"
	pb "bitbucket.org/dexterchaney/whoville/webapi/rpc/apinator"
)

//Server implements the twirp api server endpoints
type Server struct {
	VaultToken string
	VaultAddr  string
	CertPath   string
}

func (s *Server) ListServiceTemplates(ctx context.Context, req *pb.ListReq) (*pb.ListResp, error) {
	mod, err := kv.NewModifier(s.VaultToken, s.VaultAddr, s.CertPath)
	if err != nil {
		return nil, err
	}

	listPath := "templates/" + req.Service
	secret, err := mod.List(listPath)
	if err != nil {
		return nil, err
	}

	if len(secret.Warnings) > 0 {
		for _, warning := range secret.Warnings {
			fmt.Printf("Warning: %s\n", warning)
		}
		return nil, errors.New("Warnings generated from vault " + req.Service)
	}

	fileNames := []string{}
	for _, fileName := range secret.Data["keys"].([]interface{}) {
		if strFile, ok := fileName.(string); ok {
			if strFile[len(strFile)-1] != '/' { // Skip subdirectories where template files are stored
				fileNames = append(fileNames, strFile)
			}
		}
	}

	return &pb.ListResp{
		Templates: fileNames,
	}, nil
}

// GetTemplate makes a request to the vault for the template found in <service>/<file>/template-file
// Returns the template data in base64 and the template's extension. Returns any errors generated by vault
func (s *Server) GetTemplate(ctx context.Context, req *pb.TemplateReq) (*pb.TemplateResp, error) {
	// Connect to the vault
	mod, err := kv.NewModifier(s.VaultToken, s.VaultAddr, s.CertPath)
	if err != nil {
		return nil, err
	}

	// Get template data from information in request.
	path := "templates/" + req.Service + "/" + req.File + "/template-file"
	data, err := mod.ReadData(path)
	if err != nil {
		return nil, err
	}

	if data == nil {
		return nil, errors.New("No file " + req.File + " under " + req.Service)
	}

	// Return retrieved data in response
	return &pb.TemplateResp{
		Data: data["data"].(string),
		Ext:  data["ext"].(string)}, nil
}

// Validate checks the vault to see if the requested credentials are validated
func (s *Server) Validate(ctx context.Context, req *pb.ValidationReq) (*pb.ValidationResp, error) {
	mod, err := kv.NewModifier(s.VaultToken, s.VaultAddr, s.CertPath)
	if err != nil {
		return nil, err
	}
	mod.Env = req.Env

	servicePath := "verification/" + req.Service
	data, err := mod.ReadData(servicePath)
	if err != nil {
		return nil, err
	}

	if data == nil {
		return nil, errors.New("No verification for " + req.Service + " found under " + req.Env + " environment")
	}

	return &pb.ValidationResp{IsValid: data["verified"].(bool)}, nil
}
