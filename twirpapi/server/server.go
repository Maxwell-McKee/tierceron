package main

import (
	"context"
	"flag"
	"net/http"

	pb "bitbucket.org/dexterchaney/whoville/twirpapi/rpc/templatesapi"
	"bitbucket.org/dexterchaney/whoville/vault-helper/kv"
)

var vaulttoken *string
var vaultaddr *string
var certPath *string

type Server struct{}

// GetTemplate makes a request to the vault for the template found in <service>/<file>/template-file
// Returns the template data in base64 and the template's extension. Returns any errors generated by vault
func (s *Server) GetTemplate(ctx context.Context, req *pb.TemplateReq) (*pb.TemplateResp, error) {
	// Connect to the vault
	mod, err := kv.NewModifier(*vaulttoken, *vaultaddr, *certPath)
	if err != nil {
		return nil, err
	}

	// Get template data from information in request.
	path := "templates/" + req.Service + "/" + req.File + "/template-file"
	data, err := mod.ReadData(path)
	if err != nil {
		return nil, err
	}

	// Return retrieved data in response
	return &pb.TemplateResp{
		Data: data["data"].(string),
		Ext:  data["ext"].(string)}, nil
}

// Simple implementation of server for testing. Can be reworked/replaced
func main() {
	vaulttoken = flag.String("token", "", "")
	vaultaddr = flag.String("addr", "http://127.0.0.1:8200", "")
	certPath = flag.String("certPath", "certs/cert_files/serv_cert.pem", "Path to the server certificate")

	flag.Parse()

	server := &Server{}
	twirpHandler := pb.NewTemplatesServer(server, nil)

	http.ListenAndServe(":8080", twirpHandler)
}
