package kv

import (
	"errors"
	"github.com/hashicorp/vault/api"
)

// Modifier maintains references to the active client and
// respective logical needed to write to the vault. Path
// can be changed to alter where in the vault the key,value
// pair is stored
type Modifier struct {
	client  *api.Client  // Client connected to vault
	logical *api.Logical // Logical used for read/write options
	Env     string       // Environment (local/dev/QA; Initialized to secrets)
}

// Constructs a new modifier struct and connects to the vault
// @param token 	The access token needed to connect to the vault
// @param address	The address of the API endpoint for the server
// @return 			A pointer to the newly contstructed modifier object (Note: path set to default),
// 		   			Any errors generated in creating the client
func NewModifier(token string, address string) (*Modifier, error) {
	if len(address) == 0 {
		address = "http://127.0.0.1:8200" // Default address
	}

	// Create client
	modClient, err := api.NewClient(&api.Config{
		Address: address,
	})

	// Return errors if found in client creation
	if err != nil {
		return nil, err
	}

	// Set access token and path for this modifier
	modClient.SetToken(token)

	// Return the modifier
	return &Modifier{client: modClient, logical: modClient.Logical(), Env: "secret"}, nil
}

// Writes the key,value pairs in data to the vault
// @param 	data A set of key,value pairs to be written
//
// @return	Warnings (if any) generated from the vault,
//			errors generated by writing
func (m *Modifier) Write(path string, data map[string]interface{}) ([]string, error) {
	// Wrap data and send
	sendData := map[string]interface{}{"data": data}
	Secret, err := m.logical.Write(m.Env+"/data/"+path, sendData)
	if Secret == nil { // No warnings
		return nil, err
	} else {
		return Secret.Warnings, err
	}
}

// ReadData Reads the most recent data from the path referenced by this Modifier
// @return	A Secret pointer that contains key,value pairs and metadata
//			errors generated from reading
func (m *Modifier) ReadData(path string) (map[string]interface{}, error) {
	secret, err := m.logical.Read(m.Env + "/data/" + path)
	if data, ok := secret.Data["data"].(map[string]interface{}); ok {
		return data, err
	} else {
		return nil, errors.New("Could not get data from vault response")
	}
}

// ReadMetadata Reads the Metadata from the path referenced by this Modifier
// @return	A Secret pointer that contains key,value pairs and metadata
//			errors generated from reading
func (m *Modifier) ReadMetadata(path string) (map[string]interface{}, error) {
	secret, err := m.logical.Read(m.Env + "/data/" + path)
	if data, ok := secret.Data["metadata"].(map[string]interface{}); ok {
		return data, err
	} else {
		return nil, errors.New("Could not get metadata from vault response")
	}
}
